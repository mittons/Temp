on:
  push:
    branches:
      - staging

jobs:
  test-version-refs:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      # Push to main/Main
      - name: Push to main 
        # Only pushes to main if the previous steps are successful
        if: success()
        run: |
          # Configure git
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"
          git config pull.rebase false

          # Get the latest commit message associated with this branch (assuming this command will be associate with this branch)
          latest_commit_message=$(git log -1 --pretty=%B)

          # Checkout the main branch and perform a squash merge, favoring changes from staging (the branch this workflow is triggered by) in merge conflicts.
          git fetch --all
          git checkout main

          git merge -X theirs --squash staging --allow-unrelated-histories

          git add -A

          # Add a prefix and use the latest commit message from staging
          commit_message="MERGE FROM STAGING: $latest_commit_message"

          # Commit with the new message!
          git commit -m "$commit_message"

          # Push to commits to main
          git push origin main

          # Go back to staging
          git checkout staging
          # Merge and push, the squashed commit we created in main, into staging history.
          git merge main --allow-unrelated-histories
          git push origin staging
        
